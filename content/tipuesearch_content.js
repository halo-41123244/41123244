var tipuesearch = {"pages": [{'title': 'About', 'text': '課程名稱: 電腦輔助設計與實習 \n 課程評分: \n 學習心得報告 (60%)  - MS Teams 線上參與，6人一組每三週發表學習心得。 \n w3、w7、w10、w14、w17、w18 \n 學習心得報告主題 : \n w3: 用什麼套件完成  5-bar Linkage Plotter  與  Openduck mini  零組件設計繪圖？  Solvespace ,  Siemens NX ,  Onshape  或其他？各有什麼優缺點？ ( plotter.7z ,  open_duck_mini.7z ) \n w7 ( 2a 採 Youtube 影片簡報 ):  5-bar Linkage Plotter  與  Openduck mini \xa0零組件設計繪製完成之後，如何切割零件? 為何要切割零件？ 如何利用  Webots  進行後續的控制系統設計與動態模擬 (Dynamic Simulation)？( plotter_project.7z ) \n w10:  Webots  是什麼？有什麼特點？ 如何進行場景模擬？ 如何用 Python 進行控制系統設計？ ( Tutorial ) \n w14:  Webots  的模型有沒有辦法用程式方法建立? 有沒有辦法直接從 CAD 套件中轉出  Webots  的場景模型？ \n w17: 如何實作一套  5-bar Linkage Plotter  與  Openduck mini ？( Disney Bipedal Robot ) \n w18: 課程總結 \n 個人與分組網站維護 (40%)  - 每週至少兩次推送與課程進度相關的學習內容與心得。 \n w9 期中自評、w18 期末自評 \n', 'tags': '', 'url': 'About.html'}, {'title': '練習', 'text': '', 'tags': '', 'url': '練習.html'}, {'title': 'Tutorial1', 'text': '教學目的 \n \n \n 本章的目的是解說 Webots 的基本概念，這些概念在自行創建模擬場景 (.wbt) 時必須用到。 \n \n \n 讓你熟悉機器人及其環境的模型建構流程，以及機器人控制器 (controllers) 的程式設計。 \n \n \n 本章適合 Webots 的初學者，但仍然需要有程式設計背景（範例使用 Python） \n \n \n 教學流程被設計為「導引課程」形式，每個子課程都有明確教育目標、互動操作步驟，以及結論小節。 \n \n \n \n 重點內容整理 \n \n \n 新世界 (World) 的建立：包括地板、牆壁、障礙物 (箱子) 的添加。 \n \n \n 機器人 (以 e-puck 為範例) 的加載、位置與旋轉設定。 \n \n \n 控制器程式 (使用 Python) 的創建：取得機器人與馬達裝置、設置時間步長、控制輪子移動。 \n \n \n 模擬世界的保存與運行：保存 .wbt 檔案後執行模擬並觀察機器人動作。 \n \n \n 本章為後續教程奠基：熟悉基本操作後，可進一步探索 Webots 的進階功能。 \n \n \n \n 教學流程摘要 \n \n \n 啟動 Webots 軟體。 \n \n \n 創建新世界：File → New World，並命名檔案 (如  my_first_simulation.wbt )。 \n \n \n 添加競技場 (arena)：在場景樹 (Scene Tree) 裡新增 Solid → Shape，設定 Box 的尺寸作為地板，並指定材質與顏色。 \n \n \n 添加牆壁：於競技場周圍建立四面牆，設定位置與尺寸使其包圍地板。 \n \n \n 添加箱子 (障礙物)：在競技場中放置多個箱子，設定其尺寸、位置，並可複製移動箱子到不同位置。 \n \n \n 添加 e-puck 機器人：在場景樹中新增 Robot，從列表中選擇 e-puck，並設定其位置與旋轉。 \n \n \n 創建控制器程式： \n \n \n 在場景樹下的 e-puck 上新增 Controller，選擇使用 Python。 \n \n \n 在程式中導入  Robot 、 Motor  類別，設定  TIME_STEP ，取得左右輪電機裝置，設置輪子目標位置，使機器人移動。 \n \n \n \n \n 保存世界，點擊 Play 運行模擬，觀察機器人的動作。 \n \n \n', 'tags': '', 'url': 'Tutorial1.html'}, {'title': 'Tutorial2', 'text': '教學目的 \n \n \n 本章目的是在 Webots 中建立一個更具互動性的模擬環境：學會加入物件（如球）、設定物理特性，並「修改環境」以利後續機器人與環境互動。 \n \n \n 讓你熟悉節點（nodes）概念：知道「節點」在 Webots 世界 (.wbt) 中代表什麼、如何新增、隸屬關係如何、以及物理節點設定。\xa0 \n \n \n 學會使用 “DEF-USE” 機制來重用節點定義，從而減少重複、提升場景效率。 \n \n \n \n 重點內容整理 \n \n \n 刪除預設的地板部件 (RectangleArena)，手動新增一個新的地板 (Floor) 並調整其尺寸為 1 m x 1 m。\xa0 \n \n \n 介紹關鍵節點： \n \n \n Solid 節點：代表剛體（rigid body），Webots 的物理引擎對剛體模擬較為適合。\xa0 \n \n \n Shape、Sphere、Box 節點：分別用於定義視覺幾何與物理邊界，以及各種類型的幾何體。\xa0 \n \n \n Physics 子節點：用於定義物體是否為「動態」（會受重力／碰撞影響）或「靜態」。\xa0 \n \n \n \n \n 在場景中新增一個球 (Sphere) 作為剛體： \n \n \n 建立 Solid → Shape → PBRAppearance → Sphere 節點。設定其 radius（如 0.05 m）、subdivision 等參數。\xa0 \n \n \n 使用 boundingObject 欄位用 Sphere 定義碰撞邊界。  將球放置於機器人前方，例如在位置 {0.2, 0, 0.2}。\xa0 \n \n \n \n \n 引入 DEF-USE 機制： \n \n \n 在場景中將一個幾何（如 Sphere）用 DEF 標記一名稱（如  BALL_GEOMETRY ），然後在其他位置透過 USE 引用這定義，以避免重複。 \n \n \n 示範如何將先前兩個 Sphere 節點整合成一個定義 + 多處重用。\xa0 \n \n \n \n \n 新增四面牆 (Box 幾何) 圍繞環境：這些牆設定為靜態物件（無物理效果），用以界定模擬區域。\xa0 \n \n \n 性能提示：剛體模擬計算成本較高，建議減少邊界物件數量、限制約束、提高  WorldInfo.basicTimeStep  欄位以提升模擬速度。\xa0 \n \n \n \n 教學流程摘要 \n \n \n 開啟你在第 1 章創建的  my_first_simulation.wbt  世界檔，確保模擬暫停、虛擬時間為 0。接著使用  File → Save World As…  將其另存為  obstacles.wbt 。\xa0 \n \n \n 刪除預設的  RectangleArena  節點：在場景樹或 3D 視圖選中該節點，然後刪除。 \n \n \n 新增一個  Floor  (Solid) 節點作為地板：在場景樹中加入 TexturedBackgroundLight → Floor (Solid) 節點。設定 size 欄位為 {1, 1} 以將地板調整為 1 m × 1 m。\xa0 \n \n \n 在地板之前、機器人前方新增一個球體： \n \n \n 新增 Solid 節點 → 於其 children 欄位新增 Shape 節點，Shape 的 geometry 欄位新增 Sphere 節點； \n \n \n 為 Shape 的 appearance 欄位新增 PBRAppearance 節點，並設定 metalness = 0、roughness = 1； \n \n \n 在 Solid 的 boundingObject 欄位新增另一 Sphere 節點作為碰撞邊界； \n \n \n 在 Solid 的 physics 欄位新增 Physics 節點。 \n \n \n 將這個球體翻譯 (translation) 到位置如 {0.2, 0, 0.2}。\xa0 \n \n \n \n \n 調整球體細節：對兩個 Sphere 節點分別設置 radius = 0.05 m、subdivision = 2。 \n \n \n 使用 DEF-USE 機制： \n \n \n 為第一個 Sphere 的欄位輸入 DEF 字串（如  BALL_GEOMETRY ）； \n \n \n 刪除 boundingObject 裡的第二個 Sphere； \n \n \n 在 boundingObject 中選擇 Add → USE / BALL_GEOMETRY。此後修改第一個 Sphere 的 radius 欄位會同步影響 boundingObject。\xa0 \n \n \n 再新增第二個球，使用相同參數但透過 Shape 節點來實現 DEF-USE 重用。\xa0 \n \n \n \n \n 新增四面靜態牆壁來圍繞環境：使用單一 Box 幾何定義，並設定為靜態（無 physics 欄位或 physics = NULL）。\xa0 \n \n \n 保存模擬並可比較參考解答檔案：世界檔案可使用文字編輯器打開比對。\xa0 \n \n \n 結論：經過本章學習，能夠基於剛體 (Solid) 創建簡單環境、從場景樹視圖新增節點並修改欄位，熟悉了如 Solid、Shape、Sphere、Box 節點與 DEF-USE 機制。 \n \n \n', 'tags': '', 'url': 'Tutorial2.html'}, {'title': 'Tutorial3', 'text': '教學目的 \n \n \n 本章的目的是學習 Webots 中與  外觀（Appearance）  及  照明（Lighting）  相關的節點，讓模擬環境更加真實。 \n \n \n 學會設定物體的顏色、質感與反光特性，並瞭解不同光源對場景呈現的影響。理解良好的視覺外觀不僅影響美觀，也影響模擬中相機或感測器的運作（例如顏色辨識與循線功能）。 \n \n \n 教學結構延續前章，重點在環境視覺層面的提升與節點屬性設定。 \n \n \n \n 重點內容整理 \n \n \n 從上章的  obstacles.wbt  世界檔另存為新檔  appearance.wbt 。 \n \n \n 認識 Webots 中三種光源節點： \n \n \n DirectionalLight ：平行光（模擬太陽光），光線方向固定。 \n \n \n PointLight ：點光源（如燈泡），光線向四面八方擴散。 \n \n \n SpotLight ：聚光燈（如手電筒），有光錐角與方向。 \n \n \n \n \n 使用  TexturedBackgroundLight  節點，自動結合背景與光源，產生自然的全域光照效果。 \n \n \n 學習  Appearance  與  PBRAppearance  節點的差別： \n \n \n Appearance  為傳統光照模型 。 \n \n \n PBRAppearance  採用物理式渲染模型 (Physically-Based Rendering, PBR)，提供更真實的金屬質感與粗糙表面效果。 \n \n \n \n \n 可透過調整  baseColor ,  metalness ,  roughness  屬性改變物體表面反射與亮度特性。 \n \n \n \n 教學流程摘要 \n \n \n 開啟上章完成的  obstacles.wbt ，並使用  File → Save World As…  將其另存為  appearance.wbt 。 \n \n \n 確認場景樹中包含  TexturedBackgroundLight  節點。此節點自帶方向光 (DirectionalLight) 與背景貼圖，能自動產生柔和的照明效果。 \n \n \n 若想手動控制照明，可新增 Light 節點： \n \n \n 在根節點 (Root) 下新增  DirectionalLight  或  PointLight 。 \n \n \n 可調整  color 、 intensity 、 direction  等屬性。 \n \n \n \n \n 選取牆壁的  Shape  節點，新增外觀設定： \n \n \n 在  appearance  欄位選擇新增  PBRAppearance 。 \n \n \n 修改  baseColor  為淡藍色或其他色彩。 \n \n \n \n \n 調整反光屬性： \n \n \n 設定  metalness （金屬感）為 0～1 間的數值。 \n \n \n 設定  roughness （粗糙度）為 0～1 間的數值。 \n \n \n 觀察場景中反光與陰影變化。 \n \n \n \n \n 可以為地板或牆壁加入不同顏色與反光設定，模擬出不同材質效果。 \n \n \n 保存世界檔，點擊 Play 以檢視最終的照明與外觀效果。 \n \n \n \n 結論 \n \n \n 學會在 Webots 中使用光源與外觀節點，創建更具真實感的模擬環境。 \n \n \n 透過  PBRAppearance  調整顏色、金屬度與粗糙度，可以精確控制物體的視覺效果。 \n \n \n 理解光源數量與渲染品質之間的平衡，能協助建立兼顧美觀與效能的模擬場景。 \n \n \n', 'tags': '', 'url': 'Tutorial3.html'}, {'title': 'Tutorial4', 'text': "教學目的 \n \n \n 本章的目的是介紹  Webots 控制器（controller）編程的基礎概念與實作流程 。 \n \n \n 學會如何讓機器人  感知環境（透過感測器）  並  執行動作（透過馬達） ，以實現簡單的自動行為控制。 \n \n \n 理解場景樹（Scene Tree）節點與控制器 API 之間的關聯，學會初始化與清理控制器、初始化設備、讀取感測值、控制致動器，並建立簡單的  反饋迴路（feedback loop） 。 \n \n \n 教學著重於  Webots 功能的正確使用 ，不探討進階的機器人演算法。 \n \n \n \n 重點內容整理 \n \n \n 新世界檔案與控制器建立： \n \n \n 將前章的世界另存為  collision_avoidance.wbt 。 \n \n \n 透過  File → New → New Robot Controller…  建立新控制器（例如  epuck_avoid_collision ）。 \n \n \n 在 e-puck 節點中修改  controller  欄位以連結新控制器。 \n \n \n \n \n e-puck 模型介紹： \n \n \n 配備 8 個紅外距離感測器（ ps0  到  ps7 ），數值範圍 0–4096。 \n \n \n 感測器越接近障礙物，輸出值越大。 \n \n \n 由 DistanceSensor 節點建模，可透過  webots/distance_sensor.h  API 存取。 \n \n \n \n \n 控制器 API 概念： \n \n \n 提供介面讓使用者能夠存取模擬中的感測器與執行器。 \n \n \n 每個設備透過名稱（ WbDeviceTag ）呼叫  wb_robot_get_device()  取得。 \n \n \n 感測器需透過  .enable(time_step)  啟用。 \n \n \n \n \n 程式語言可用 C、C++、Java、Python，範例使用  Python 。 \n \n \n 控制邏輯： \n \n \n 機器人向前移動，若前方感測器偵測到障礙物，則轉向無障礙物的一側。 \n \n \n 以 UML 狀態機示意控制流程（感測 → 判斷 → 動作）。 \n \n \n \n \n \n 教學流程摘要 \n Python 中沒有主函數，程序從文件的開始處開始執行： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n \n \n \n # create the Robot instance. \n robot  =   Robot() \n # initialize devices \n # feedback loop: step simulation until receiving an exit event \n while   robot.step(TIME_STEP) ! =   - 1 : \n \xa0\xa0\xa0\xa0 # read sensors outputs \n \xa0\xa0\xa0\xa0 # process behavior \n \xa0\xa0\xa0\xa0 # write actuators inputs \n \n \n \n \n \n \n \n 機器人設備由 WbDeviceTag 引用。WbDeviceTag 由 wb_robot_get_device 函數檢索。然後，它在每個涉及此設備的函數調用中用作第一個參數。像 DistanceSensor 這樣的傳感器在使用前必須啟用。enable 函數的第二個參數定義了傳感器的刷新率。 \n 在註釋 // initialize devices 之後，獲取並啟用距離傳感器，如下所示： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n \n \n \n # initialize devices \n ps  =   [] \n psNames  =   [ \n \xa0\xa0\xa0\xa0 'ps0' ,  'ps1' ,  'ps2' ,  'ps3' , \n \xa0\xa0\xa0\xa0 'ps4' ,  'ps5' ,  'ps6' ,  'ps7' \n ] \n \xa0 \n for   i  in   range ( 8 ): \n \xa0\xa0\xa0\xa0 ps.append(robot.getDevice(psNames[i])) \n \xa0\xa0\xa0\xa0 ps[i].enable(TIME_STEP) \n \n \n \n \n \n \n \n 初始化設備後，初始化馬達： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n \n \n \n leftMotor  =   robot.getDevice( 'left wheel motor' ) \n rightMotor  =   robot.getDevice( 'right wheel motor' ) \n leftMotor.setPosition( float ( 'inf' )) \n rightMotor.setPosition( float ( 'inf' )) \n leftMotor.setVelocity( 0.0 ) \n rightMotor.setVelocity( 0.0 ) \n \n \n \n \n \n \n \n 在主循環中，在註釋 # read sensors outputs 之後，按如下方式讀取距離傳感器的值： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n \n \n \n # read sensors outputs \n psValues  =   [] \n for   i  in   range ( 8 ): \n \xa0\xa0\xa0\xa0 psValues.append(ps[i].getValue()) \n \n \n \n \n \n \n \n 在主循環中，在註釋 # process behavior 之後，檢測是否發生碰撞（即距離傳感器返回的值大於閾值），如下所示： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n \n \n \n # detect obstacles \n right_obstacle  =   psValues[ 0 ] >  80.0   or   psValues[ 1 ] >  80.0   or   psValues[ 2 ] >  80.0 \n left_obstacle  =   psValues[ 5 ] >  80.0   or   psValues[ 6 ] >  80.0   or   psValues[ 7 ] >  80.0 \n \n \n \n \n \n \n \n 最後，使用有關障礙物的信息來驅動車輪，如下所示： \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n \n \n \n MAX_SPEED  =   6.28 \n ... \n # initialize motor speeds at 50% of MAX_SPEED. \n leftSpeed\xa0  =   0.5   *   MAX_SPEED \n rightSpeed  =   0.5   *   MAX_SPEED \n # modify speeds according to obstacles \n if   left_obstacle: \n \xa0\xa0\xa0\xa0 # turn right \n \xa0\xa0\xa0\xa0 leftSpeed\xa0  =   0.5   *   MAX_SPEED \n \xa0\xa0\xa0\xa0 rightSpeed  =   - 0.5   *   MAX_SPEED \n elif   right_obstacle: \n \xa0\xa0\xa0\xa0 # turn left \n \xa0\xa0\xa0\xa0 leftSpeed\xa0  =   - 0.5   *   MAX_SPEED \n \xa0\xa0\xa0\xa0 rightSpeed  =   0.5   *   MAX_SPEED \n # write actuators inputs \n leftMotor.setVelocity(leftSpeed) \n rightMotor.setVelocity(rightSpeed) \n \n \n \n \n \n 結論 \n \n \n 控制器的主函數是程式進入點（Python 則從檔案開頭執行）。 \n \n \n 在呼叫  wb_robot_init()  之前不可使用任何 Webots API 函數，結束時需呼叫  wb_robot_cleanup() 。 \n \n \n 各設備以其節點名稱識別，並以  wb_robot_get_device()  取得。 \n \n \n 每個控制器程式作為獨立進程執行，與 Webots 主程序之間透過  libController  動態庫通信。 \n \n \n \n \n \n", 'tags': '', 'url': 'Tutorial4.html'}, {'title': 'Tutorial5', 'text': '教學目的 \n \n \n 本章的目的是透過在 Webots 中創建一個具有複雜形狀（由多個子幾何構成）的固體，來深入探索物理模擬的設定與控制。\xa0 \n \n \n 目標是能夠設計並建立一個由兩個球體與一根圓柱體構成的「啞鈴」模型，並了解其物理屬性如何影響模擬行為。\xa0 \n \n \n 精通 Solid 節點中多個 Shape 子節點的使用方法、Pose 節點的定位與變換、以及將圖形與物理形狀合併。\xa0 \n \n \n \n 重點內容整理 \n \n \n 從上一章的世界檔案另存為  compound_solid.wbt 。\xa0 \n \n \n 創建一個複合固體（Compound\u202fSolid）： \n \n \n 使用一個 Solid 節點，內部包含多個 Shape 節點來定義圖形與物理外形。 \n \n \n 每個 Shape 節點可用 Pose 子節點調整其  相對位置與方向 。\xa0 \n \n \n \n \n 啞鈴模型實作： \n \n \n 圓柱體（Cylinder）作為啞鈴桿：長度為\u202f0.1\u202fm，半徑為\u202f0.01\u202fm。\xa0 \n \n \n 兩個球體（Sphere）作為啞鈴重量端：球的半徑為\u202f0.03\u202fm，subdivision 設為\u202f2。\xa0 \n \n \n 將兩個球體透過其 Pose 節點移動至桿的兩端。\xa0 \n \n \n \n \n 補充說明： \n \n \n Solid 節點可包含不少於一個 Shape，且這些 Shape 可同時定義視覺與物理邊界。\xa0 \n \n \n Group 節點亦可用來將多個節點組合起來，以構建更複雜的結構。\xa0 \n \n \n \n \n \n 教學流程摘要 \n \n \n 開啟你在 Tutorial\u202f4 所創建的世界，然後使用  File → Save World As…  將其另存為  compound_solid.wbt 。 \n \n \n 在場景中新增一個 Solid 節點作為啞鈴的初始父節點。 \n \n \n 在該 Solid 裡新增一個 Cylinder Shape 節點：設定長度為\u202f0.1\u202fm、半徑為\u202f0.01\u202fm。 \n \n \n 在同一 Solid 中新增兩個 Sphere Shape 節點：設定球半徑為\u202f0.03\u202fm、subdivision\u202f=\u202f2。 \n \n \n 對每個球體 Shape，再各自使用一個 Pose 節點來設定其  translation （位置）使其位於桿的兩端。 \n \n \n 儲存並執行模擬，觀察固體是否如預期地構成啞鈴結構，同時確認其物理互動是否合理。 \n \n \n （可選）打開世界檔案為文字檢視，了解 Solid 與其子節點的階層與欄位定義。 \n \n \n \n 結論 \n \n \n 本章你學會如何在 Webots 裡構建「多幾何構成的固體」，也了解了 Solid、Shape、Pose、Group 等節點在場景中的組合方式與作用。 \n \n \n 你已掌握構造複合固體所需的關鍵參數（如長度、半徑、subdivision、translation）與節點關聯。 \n \n \n 下一步，你可以將這些結構應用於設計更複雜的模擬場景，並開始加入動力學與碰撞互動的設定。 \n \n \n', 'tags': '', 'url': 'Tutorial5.html'}, {'title': 'Tutorial6', 'text': "教學目的 \n \n \n 本章的目的是從頭開始創建一輛  四輪機器人 (4‑Wheeled Robot) ，包括車體、四個車輪、兩個距離感測器。 \n \n \n 讓你理解在 Webots 中從模型設計到控制器程式的完整流程：包括節點結構、車輪關節機構、感測器配置與程式控制。 \n \n \n 幫助你掌握建構機器人模型時 Solid／Joint／Device 節點的用途與組織方式，並在控制程式中驅動車輪、讀取感測器值並做出反應。 \n \n \n \n 重點內容整理 \n \n \n 新模擬場景：將上一章結果保存為  4_wheeled_robot.wbt ，並刪除舊的 e‑puck／球體／啞鈴與其接觸屬性，只保留地面、牆壁、燈光。 \n \n \n 機器人模型設計要點： \n \n \n 整車由 5\u202f個 Solid 節點構成：車體 + 四個車輪。 \n \n \n 車輪透過 HingeJoint 節點與車體連接。Solid、Joint、Device 的階層與組織須遵循 Webots 資料結構。 \n \n \n \n \n 車體設定：使用 Box 幾何，尺寸 (0.2,\u202f0.1,\u202f0.05)\u202fm，顏色紅色。車體節點需加入 Physics。 \n \n \n 車輪設定：每輪為 Cylinder 幾何，半徑 0.04\u202fm、厚度 0.02\u202fm。每輪透過 HingeJointParameters 指定 anchor、axis，其中軸為 (0,1,0)。車輪節點顏色綠色。 \n \n \n 感測器：新增兩個 DistanceSensor 節點為車體子節點，感測方向沿 +x 軸，並旋轉 0.3\u202frad 與車前方產生角度。感測器圖形用邊長 0.01\u202fm 的 Cube，顏色藍色。 \n \n \n 控制器程式設計：導入 motor 模組，取得四輪 Motor 裝置，設定位置為無限旋轉 ( setPosition(float('inf')) )，然後設置速度。程式中讀取距離感測器值，若感測值低於某閾值表示前方有障礙，則啟動避障邏輯。 \n \n \n 測試與解決方案：可開啟 robot‑window 實時觀察感測器與馬達值。程式名稱例如  four_wheeled_collision_avoidance ，並在 Robot 節點中設定其 controller 欄位。 \n \n \n \n 教學流程摘要 \n \n \n 開啟上一個世界檔案，另存為  4_wheeled_robot.wbt 。 \n \n \n 刪除不再使用的舊模型元素（e‑puck、球、啞鈴、接觸屬性），保留基本環境（地面、牆壁、燈光）。 \n \n \n 在場景樹末端添加一個 Robot 節點，並作為整車根節點。 \n \n \n 在 Robot 節點下，添加四個 HingeJoint 節點，每個 HingeJoint 的 endPoint 為一個 Solid → Shape (Cylinder) 用於車輪。設定 Cylinder 的尺寸、顏色、位置與旋轉。為 HingeJoint 設定 HingeJointParameters 的 anchor 與 axis。 \n \n \n 車輪 Motor 裝置命名為  wheel1  ~  wheel4 ，取得並初始化。 \n \n \n 添加兩個 DistanceSensor 裝置，設置其名稱、位置、旋轉、圖形形狀（cube）、顏色。啟用它們以讀取距離。 \n \n \n 寫控制器程式：設定 TIME_STEP，如 64\u202fms。初始化 robot、感測器、馬達。主迴圈中讀取感測器值、判斷障礙、調整左右輪速度。 \n \n \n 保存檔案、設定 Robot 節點的 controller 欄位為控制器程式名稱，運行模擬並觀察機器人的避障行為。 \n \n \n 比對官方解答世界檔（位於 solution 資料夾）以確認模型設計與控制器程式正確。 \n \n \n \n 結論 \n \n \n 完成本章後，你能夠從零設計、建構並控制一輛四輪機器人。 \n \n \n 你已熟悉 Solid／Joint／Device 節點在 Webots 中的用途、如何構建機器人模型、以及如何編寫控制器驅動與感測。 \n \n \n 這為後續加入更多感測器、控制策略或更複雜機器人奠定了基礎。 \n \n \n", 'tags': '', 'url': 'Tutorial6.html'}, {'title': 'Tutorial7', 'text': '目標 \n 將上一個教學中建立的四輪機器人從世界檔 ( .wbt ) 移到 PROTO 檔案，方便在不同世界或多次使用同一機器人，而不需要複製整個定義。 \n \n 1. 建立 PROTO 檔案 \n \n \n 開啟上一個世界檔  4_wheels_robot.wbt 。 \n \n \n 在  protos  資料夾中建立新檔  FourWheelsRobot.proto 。 \n \n \n PROTO 檔案的基本結構： \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n \n \n \n #VRML_SIM R2025a utf8 \n PROTO protoName [ \n \xa0\xa0 protoFields \n ] \n { \n \xa0\xa0 protoBody \n } \n \n \n \n \n \n \n \n protoName ：PROTO 名稱，例如  FourWheelsRobot \n \n \n protoFields ：可修改的欄位（fields），目前可以先留空 \n \n \n protoBody ：根節點內容（即 Robot 節點） \n \n \n \n \n 將原本世界檔中的  Robot { … }  節點複製到  protoBody 。 \n \n \n \n \n 2. 在世界中使用 PROTO \n \n \n 儲存 PROTO 檔後，重新開啟 Webots。 \n \n \n 可以在  PROTO nodes (Current Project)  中找到  FourWheelsRobot  並新增到世界中。 \n \n \n 可以新增多個相同的機器人節點。 \n \n \n \n 3. 新增可修改欄位（Fields） \n \n \n 編輯 PROTO 檔案，增加可調整的欄位： \nfield SFVec3f translation 0 0 0 field SFRotation rotation 0 0 1 0 field SFFloat bodyMass 1 \n 最終 PROTO 範例： \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n \n \n \n #VRML_SIM R2025a utf8 \n PROTO FourWheelsRobot [ \n \xa0\xa0 field SFVec3f\xa0\xa0\xa0 translation\xa0 0 0 0 \n \xa0\xa0 field SFRotation rotation\xa0\xa0\xa0\xa0 0 0 1 0 \n \xa0\xa0 field SFFloat\xa0\xa0\xa0 bodyMass\xa0\xa0\xa0\xa0 1 \n ] \n { \n \xa0\xa0 Robot { \n \xa0\xa0\xa0\xa0 translation IS translation \n \xa0\xa0\xa0\xa0 rotation IS rotation \n \xa0\xa0\xa0\xa0 children [ \n \xa0\xa0\xa0\xa0\xa0\xa0 # list of children nodes \n \xa0\xa0\xa0\xa0 ] \n \xa0\xa0\xa0\xa0 boundingObject USE BODY \n \xa0\xa0\xa0\xa0 physics Physics { \n \xa0\xa0\xa0\xa0\xa0\xa0 density -1 \n \xa0\xa0\xa0\xa0\xa0\xa0 mass IS bodyMass \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 controller  "four_wheels_collision_avoidance" \n \xa0\xa0 } \n } \n \n \n \n \n \n \n \n 4. 小結 \n 你現在學會了： \n \n \n 將 Webots 節點定義轉換成 PROTO。 \n \n \n 在 PROTO 中開放欄位（fields）供外部修改。 \n \n \n 連結 PROTO 欄位與內部節點屬性 ( IS  關鍵字)。 \n \n \n 這樣可以讓機器人更具模組化與可重用性。 \n', 'tags': '', 'url': 'Tutorial7.html'}, {'title': '練習檔', 'text': 'Test \n', 'tags': '', 'url': '練習檔.html'}, {'title': 'Webots模擬', 'text': '', 'tags': '', 'url': 'Webots模擬.html'}, {'title': '成品', 'text': '畫圓 \n \n \n 畫方形 \n \n Webots模擬檔 \n', 'tags': '', 'url': '成品.html'}, {'title': '模擬筆記', 'text': '\n 匯入到 Webots 前，確保 CAD 模型的長度單位為「m」或於匯出時把所有座標縮放 0.001（mm → m）。若忽略，Webots 會把 mm 數值當成 m 讀取，導致幾何放大 1000 倍。\xa0 \n Inventor更改單位方法\xa0\xa0工具>文件設定>單位>公釐改公尺 \n 在 Inventor 中，Y 軸為垂直向上（Y-up）；  在 Webots 中，Z 軸為垂直向上（Z-up），若直接匯出模型不做旋轉，零件會躺平。  解法：在建立模型時按照Webots的座標軸。(或在 Webots  Transform.rotation  設定）。 \n \n \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \xa0 \n \n 在使用Webots時，把座標系統開啟\xa0 View>Optional Rendering>Show Coordinate System。 \n 練習Webots時可到 官方網站 查看每個功能，也可以 點這裡 查看詳細的中文教學影片。 \n \n \n \n \n', 'tags': '', 'url': '模擬筆記.html'}]};